#!/bin/bash
set -u

# Patrick Miller
# Do all ldpred steps 1 phenotype at a time, saving only the weights and not the intermediate results.
# The reason we do this is because the intermediate results are much too large to save permanently, but the weights
# are relatively small.
# This version maps genetic files onto task ids

# The script allows cleaning (removing intermediate results) as well as testing (not running commands, making sure files are ok)
# by setting the testing and clean flags respectively. Eventually these will be arguments.
# If intermediate results are present where expected, the program does not recompute them.

#$ -M patr1ckm.crc@gmail.com	 # Email address for job notification
#$ -m ae		 # Send mail when job begins, ends and aborts
#$ -pe smp 10  #Specify parallel environment and legal core size
#$ -q *@@daccss		 # Specify queue
#$ -N ldp	         # Specify job name
#$ -t 1-2        # number of chunks
#$ -o SGE_Output/

mname=$1
echo "running ldpred for $1"
loc=../3_subsets
# This is so gfiles is 1-indexed, to map onto SGE_TASK_ID
gfiles=("" $(awk -F, 'NR > 1 {print $1}' config))
echo "read the following genetic files: ${gfiles[@]}"
ns=ns.txt
ld_pref=$mname
ld_rad=(300 800)
# if testing=true, commands are printed but not executed. Useful for checking filenames.
testing=true
# remove intermediate results?
clean=false

# Check if $SGE_TASK_ID is set. If not, just set $i=1. This can be changed to $2 for example.
if [ -z $SGE_TASK_ID ]; then
 echo "SGE_TASK_ID= $SGE_TASK_ID"	
 gf=${gfiles[$SGE_TASK_ID]}
 ld_rad1=${ld_rad[$SGE_TASK_ID]}
 i=$SGE_TASK_ID
else
 gf=${gfiles[1]}
 ld_rad1=${ld_rad[1]}
 i=1
fi

echo "cleaning = $clean, testing = $testing"
echo "running script using $gf"

## 2. Clean data, add c-bp
f=$loc/0_ma/dropntr/"$mname".tbl
ssfname1=$(echo "$loc/2_ssf/g$i/"$mname".ssf")

echo "cleaning raw ma $f, adding c-bp from  $gf"
if [[ "$testing" = false ]] && [[ ! -f $ssfname1 ]]; then 
  Rscript clean.R $f $ $ssfname1
  echo "cleaned, files written to 2_ssf/g$i"
fi

n=$(grep ^$mname ns.txt | awk '{print $2}' )

## 3. Coordinate
module load python/2.7.8
python test.py


cname1=$(echo "$loc/3_coord/g$i/$mname.coord")

echo "coordinating genotypes with --gf=$gf, --ssf=$ssfname1, --N=$n, --out=$cname1 --ssf_format=STANDARD"
if [[ "$testing" = false ]] && [[ ! -f $cname1 ]]; then 
  python ~/bin/ldpred/coord_genotypes.py --gf=$gf --ssf=$ssfname1 --N=$n --out=$cname1 --ssf_format=STANDARD 
  echo "results written to $cname1"
fi

## 4. LDpred

lname1=$(echo "$loc/4_pred/g$i/$mname/$mname")

if mkdir $loc/4_pred/g$i/$mname; then
 echo "mkdir $loc/4_pred/g$i/$mname"
fi

nweights=$( ls $loc/4_pred/g$i/$mname/ | wc -l )

echo "python ~/bin/ldpred/LDpred.py --coord=$cname1 --ld_radius=$ld_rad1 --N=$n --out=$lname1 --ld_prefix=$loc/4_pred/$gf/$ld_pref"
if [[ "$testing" = false ]] && (( $nweights == 0 )); then 
 python ~/bin/ldpred/LDpred.py --coord=$cname1 --ld_radius=$ld_rad1 --N=$n --out=$lname1 --ld_prefix=$loc/4_pred/g$i/$ld_pref
 echo "results written to $lname1"
fi

if [[ "$testing" = false ]] && [[ $clean = true ]]; then 
  echo " rm $cname1"
  rm $cname1
fi

## 5. Compute scores
echo " computing polygenic scores from ldpred weights"


echo "computing .raw files for $loc/4_pred/g$i/$mname/"
nraw=$(ls $loc/4_pred/g$i/$mname/*.raw | wc -l)
nscore=$(ls $loc/5_pred/g$i/$mname/ | wc -l)

if [[ "$testing" = false ]] && (( $nraw == 0 )); then
 wfiles=$(echo $loc/4_pred/g$i/$mname/*.txt)
 for wf in $wfiles
 do
   rawname=${wf%.txt}
   echo "writing $wf > $rawname.raw"
   awk '{print $3 "\t" $4 "\t" $6}' $wf > $rawname.raw
 done
 awk '{print $3 "\t" $4 "\t" $5}' $mname_LDpred-inf.txt > $mname_LE.txt
fi

if [[ "$testing" = false ]] && (( $nscore == 0 )); then
 rfiles=$(echo $loc/4_pred/g$i/$mname/*.raw)
 for rf in $rfiles
 do
   scorename=${rf/4_pred/5_scores}
   scorename=${scorename%.raw}
   echo "plink2 --bfile $gf --score $rf --out $scorename --noweb"
   plink2 --bfile $gf --score $rf --out $scorename --noweb
 done
fi


